<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Force Graph</title>
<style>
  html, body { height:100%; margin:0; background:#000; }
  body { overflow:hidden; }
  canvas { display:block; width:100vw; height:100vh; image-rendering: pixelated; touch-action: none; }
  .hint { position:fixed; left:10px; bottom:10px; font:12px/1.2 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; color:#7a7a7a; opacity:0.9; }
  .refresh-btn { 
    position:fixed; 
    bottom:20px; 
    right:20px; 
    padding:8px 12px; 
    background:#333; 
    color:#fff; 
    border:none; 
    border-radius:6px; 
    font:12px/1.2 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; 
    cursor:pointer; 
    opacity:0.9; 
    transition:opacity 0.2s;
    z-index:1000;
    display:none;
  }
  .refresh-btn:hover { opacity:1; }
  
  /* Mobile adaptations */
  @media (max-width: 768px) {
    .hint { display:none; }
    .refresh-btn { 
      display:block;
      bottom:25px; 
      right:50%; 
      transform:translateX(50%);
      padding:10px 16px;
      font-size:14px;
      background:#444;
      box-shadow:0 2px 8px rgba(0,0,0,0.3);
    }
    canvas { 
      width:100vw; 
      height:100vh; 
      position:fixed; 
      top:0; 
      left:0;
    }
  }
  
  /* Prevent zoom on mobile */
  @media (max-width: 768px) {
    body { 
      touch-action: manipulation; 
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
  }
</style>
</head>
<body>
<canvas id="stage"></canvas>
<div class="hint">press <b>R</b> to reshuffle • <b>drag</b> hubs to reposition</div>
<button class="refresh-btn" id="refreshBtn">Reshuffle</button>
<script type="module">
import { forceSimulation, forceManyBody, forceCenter, forceLink, forceCollide } from 'https://cdn.skypack.dev/d3-force@3';

// --- Config ---
const N = 150;                      // agents
const HUB_COUNT = 4;                // fixed number of hubs
const SHARED_RATIO = 0.3;           // 50% of non-hubs connect to ALL hubs
const EXTRA_MIN = 0, EXTRA_MAX = 2; // extra non-hub↔non-hub links per node
const EDGE_COLOR = '#2a2a2a';       // 1px dark grey
const NODE_COLOR = '#fff';          // white
const NODE_SIZE = 2;                // 2x2 pixels (CSS px)

// --- Canvas setup (HiDPI aware) ---
const canvas = document.getElementById('stage');
const ctx = canvas.getContext('2d');
function resize() {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const w = Math.floor(window.innerWidth);
  const h = Math.floor(window.innerHeight);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
}
window.addEventListener('resize', resize);
resize();

// --- Utilities ---
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function randPick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function key(u,v){ return u<v ? u+','+v : v+','+u; }
function getNodeRef(n){ return (typeof n === 'object') ? n : graph.nodes[n]; }
function safeXY(n){ return n && Number.isFinite(n.x) && Number.isFinite(n.y); }

// --- Graph generation ---
function makeGraph(n=N){
  const nodes = Array.from({length:n}, (_,i)=>({id:i}));
  const ids = nodes.map(n=>n.id);

  // 1) Choose hubs (exact HUB_COUNT)
  const hubs = new Set();
  while(hubs.size < Math.min(HUB_COUNT, n)) { hubs.add(randPick(ids)); }
  for (const id of ids) nodes[id].hub = hubs.has(id); // mark hubs

  const nonHubs = ids.filter(id=>!hubs.has(id));

  // 2) Edge store helpers
  const links = [];
  const edgeSet = new Set();
  const addEdge = (u,v)=>{
    if(u===v) return false; // no self-loops
    const k = key(u,v);
    if(edgeSet.has(k)) return false; // no duplicates
    edgeSet.add(k); links.push({source:u, target:v}); return true;
  };

  // 3) Split non-hubs into SHARED set S and EXCLUSIVE buckets for each hub
  const shuffled = nonHubs.slice().sort(()=>Math.random()-0.5);
  const sharedCount = Math.floor(shuffled.length * SHARED_RATIO);
  const S = new Set(shuffled.slice(0, sharedCount));
  const R = shuffled.slice(sharedCount);

  // Distribute R (exclusive agents) across hubs as evenly as possible
  const hubList = [...hubs];
  const buckets = new Map(hubList.map(h=>[h, []]));
  for (let i=0; i<R.length; i++) {
    const h = hubList[i % hubList.length];
    buckets.get(h).push(R[i]);
  }

  // 4) Wire connections
  // 4a) Shared agents connect to ALL hubs
  for (const a of S) for (const h of hubList) addEdge(h, a);
  // 4b) Exclusive agents connect ONLY to their assigned hub
  for (const h of hubList) for (const a of buckets.get(h)) addEdge(h, a);

  // 5) Extra non-hub↔non-hub links (occasional)
  const extraTargets = new Map(nonHubs.map(id=>[id, randInt(EXTRA_MIN, EXTRA_MAX)]));
  let guard = 100000;
  function remainingTotal(){ let s=0; for(const v of extraTargets.values()) s+=v; return s; }
  while(remainingTotal()>0 && guard--){
    const needers = nonHubs.filter(id=>extraTargets.get(id)>0);
    if(!needers.length) break;
    const u = randPick(needers);
    let candidates = nonHubs.filter(v=>v!==u);
    let tries = 20, linked=false;
    while(tries-- && candidates.length){
      const v = randPick(candidates);
      if(addEdge(u, v)){
        extraTargets.set(u, extraTargets.get(u)-1);
        extraTargets.set(v, Math.max(0, extraTargets.get(v)-1));
        linked=true; break;
      } else {
        candidates = candidates.filter(x=>x!==v);
      }
    }
    if(!linked){ extraTargets.set(u, Math.max(0, extraTargets.get(u)-1)); }
  }

  return {nodes, links, hubs, shared:S};
}

let graph = makeGraph();

// --- Sanity tests ("test cases") ---
function runTests({nodes, links, hubs, shared}){
  // Build adjacency
  const adj = new Map(nodes.map(n=>[n.id, new Set()]));
  for(const e of links){
    const s = (typeof e.source === 'object') ? e.source.id : e.source;
    const t = (typeof e.target === 'object') ? e.target.id : e.target;
    console.assert(s!==t, 'Self-loop detected at node', s);
    const k = key(s,t);
    console.assert(k, 'Key issue');
    adj.get(s).add(t); adj.get(t).add(s);
  }
  // No duplicate edges
  const seen = new Set();
  for(const e of links){
    const s = (typeof e.source === 'object') ? e.source.id : e.source;
    const t = (typeof e.target === 'object') ? e.target.id : e.target;
    const k = key(s,t);
    console.assert(!seen.has(k), 'Duplicate edge detected', k);
    seen.add(k);
  }
  const hubIds = new Set([...hubs]);
  const nonHubs = nodes.filter(n=>!hubIds.has(n.id));

  // Test: hub↔hub edges should NOT exist
  for(const h of hubs){
    for(const h2 of hubs){ if(h2===h) continue; console.assert(!adj.get(h).has(h2), 'Forbidden hub↔hub edge exists', h, '<->', h2); }
  }

  // Test: shared agents connect to ALL hubs
  for(const a of shared){
    for(const h of hubs){ console.assert(adj.get(a).has(h), 'Shared agent missing hub', a, '<->', h); }
  }

  // Test: exclusive agents connect to EXACTLY one hub
  for(const u of nonHubs){
    const hubNeighbors = [...adj.get(u.id)].filter(v=>hubIds.has(v));
    if(shared.has(u.id)){
      console.assert(hubNeighbors.length===hubIds.size, 'Shared agent does not connect to all hubs', u.id, hubNeighbors.length);
    } else {
      console.assert(hubNeighbors.length===1, 'Exclusive agent must connect to exactly one hub', u.id, hubNeighbors.length);
    }
  }

  // Connectivity: Each agent should have >=1 hub neighbor
  for(const u of nonHubs){
    const hubNeighbors = [...adj.get(u.id)].filter(v=>hubIds.has(v));
    console.assert(hubNeighbors.length>=1, 'Agent without hub connection', u.id);
  }

  // Additional tests
  const expectedShared = Math.floor(nonHubs.length * SHARED_RATIO);
  console.assert(shared.size === expectedShared, 'Shared set size mismatch', shared.size, 'expected', expectedShared);
  console.assert(hubs.size === Math.min(HUB_COUNT, nodes.length), 'Hub count mismatch', hubs.size);

  // New: whole-graph connectivity via DFS
  const visited = new Set();
  const stack = [0]; visited.add(0);
  while(stack.length){
    const x = stack.pop();
    for(const y of adj.get(x)) if(!visited.has(y)){ visited.add(y); stack.push(y); }
  }
  console.assert(visited.size === nodes.length, 'Graph is not connected!', visited.size, '/', nodes.length);
}
runTests(graph);

// --- Force simulation ---
let sim = forceSimulation(graph.nodes)
  .force('charge', forceManyBody().strength(-30))
  .force('center', forceCenter(window.innerWidth/2, window.innerHeight/2))
  .force('link', forceLink(graph.links).id(d=>d.id).distance(120).strength(0.6))
  .force('collide', forceCollide(2));

// keep centered on resize
window.addEventListener('resize', ()=>{
  sim.force('center', forceCenter(window.innerWidth/2, window.innerHeight/2));
});

// --- Draw ---
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // edges
  ctx.strokeStyle = EDGE_COLOR;
  ctx.lineWidth = 1;
  ctx.globalAlpha = 1;
  for(const e of graph.links){
    const s = getNodeRef(e.source);
    const t = getNodeRef(e.target);
    if(!safeXY(s) || !safeXY(t)) continue;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(t.x, t.y);
    ctx.stroke();
  }
  // nodes (2x2 or 3x3 px squares) with faint halo for hubs
  for(const n of graph.nodes){
    if(!safeXY(n)) continue;
    const size = n.hub ? 3 : NODE_SIZE;
    const x = Math.round(n.x) - Math.floor(size/2);
    const y = Math.round(n.y) - Math.floor(size/2);
    if(n.hub){
      ctx.save();
      ctx.globalAlpha = 0.15;
      ctx.fillStyle = NODE_COLOR;
      ctx.beginPath();
      ctx.arc(Math.round(n.x)+0.5, Math.round(n.y)+0.5, 8, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    ctx.fillStyle = NODE_COLOR;
    ctx.fillRect(x, y, size, size);
  }
}

sim.on('tick', draw);

// --- Interactions (hubs are draggable) ---
let dragging = null;
const DRAG_RADIUS2 = 15*15; // pixels^2 search radius for hubs (larger for mobile)
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

function nearestHub(x,y){
  let best=null, bd=DRAG_RADIUS2;
  for(const n of graph.nodes){
    if(!n.hub || !safeXY(n)) continue;
    const dx=n.x-x, dy=n.y-y; const d=dx*dx+dy*dy;
    if(d<bd){ bd=d; best=n; }
  }
  return best;
}

function getEventCoordinates(e){
  const rect = canvas.getBoundingClientRect();
  let x, y;
  if(e.touches && e.touches.length > 0){
    // Touch event
    x = e.touches[0].clientX - rect.left;
    y = e.touches[0].clientY - rect.top;
  } else {
    // Mouse/pointer event
    x = e.clientX - rect.left;
    y = e.clientY - rect.top;
  }
  return {x, y};
}

function startDrag(e){
  e.preventDefault();
  const {x, y} = getEventCoordinates(e);
  const hub = nearestHub(x,y);
  if(hub){
    dragging = hub; 
    hub.fx = x; 
    hub.fy = y; 
    if(!isMobile) canvas.style.cursor='grabbing';
    sim.alphaTarget(0.35).restart();
  }
}

function moveDrag(e){
  e.preventDefault();
  const {x, y} = getEventCoordinates(e);
  if(dragging){ 
    dragging.fx = x; 
    dragging.fy = y; 
    return; 
  }
  if(!isMobile){
    const hub = nearestHub(x,y);
    canvas.style.cursor = hub ? 'grab' : 'default';
  }
}

function endDrag(){
  if(dragging){ 
    dragging.fx=undefined; 
    dragging.fy=undefined; 
    dragging=null; 
    if(!isMobile) canvas.style.cursor='default'; 
  }
  sim.alphaTarget(0);
}

// Touch events for mobile
canvas.addEventListener('touchstart', startDrag, {passive: false});
canvas.addEventListener('touchmove', moveDrag, {passive: false});
canvas.addEventListener('touchend', endDrag);
canvas.addEventListener('touchcancel', endDrag);

// Pointer events (works on both desktop and mobile)
canvas.addEventListener('pointerdown', startDrag);
canvas.addEventListener('pointermove', moveDrag);
canvas.addEventListener('pointerup', endDrag);
canvas.addEventListener('pointerleave', endDrag);

// Function to reshuffle the graph
function reshuffleGraph(){
  endDrag();
  sim.stop();
  graph = makeGraph();
  runTests(graph);
  sim = forceSimulation(graph.nodes)
    .force('charge', forceManyBody().strength(-30))
    .force('center', forceCenter(window.innerWidth/2, window.innerHeight/2))
    .force('link', forceLink(graph.links).id(d=>d.id).distance(30).strength(0.9))
    .force('collide', forceCollide(2))
    .on('tick', draw);
}

// Reshuffle graph with R key
window.addEventListener('keydown', (e)=>{
  if(e.key.toLowerCase()==='r'){
    reshuffleGraph();
  }
});

// Refresh button functionality
document.getElementById('refreshBtn').addEventListener('click', reshuffleGraph);
</script>
</body>
</html>

